# Role Definition

ä½ æ˜¯ä¸€ä½è³‡æ·±çš„ Python è»Ÿé«”æ¶æ§‹å¸«ï¼Œå°ˆç²¾æ–¼ Microsoft Graph APIã€AsyncIO éåŒæ­¥ç·¨ç¨‹ä»¥åŠä¼æ¥­ç´š Chatbot é–‹ç™¼ã€‚



# Project Context

æˆ‘å€‘è¦é–‹ç™¼ä¸€å€‹ã€Œä¼æ¥­å…§ç¶²ç‰ˆ Microsoft Teams å¤šé‡æ©Ÿå™¨äººç³»çµ± (Multi-Bot System)ã€ã€‚

ç›®æ¨™æ˜¯éƒ¨ç½²åœ¨å…¬å¸å…§ç¶²ä¼ºæœå™¨ (On-Premise)ï¼Œä¸ä½¿ç”¨ Azure Bot Serviceï¼Œä¸é–‹æ”¾é˜²ç«ç‰† Inbound Portã€‚

æ¯å€‹éƒ¨é–€ (HR, IT, DevOps) æœƒæœ‰ä¸€å€‹ç¨ç«‹çš„ Bot å¸³è™Ÿï¼Œå¾Œç«¯çµ±ä¸€å°æ¥å…§éƒ¨çš„ LLM æœå‹™èˆ‡å¤–éƒ¨å·¥å…· (Jira, etc.)ã€‚



# Technical Stack & Constraints

1.  **èªè¨€ï¼š** Python 3.10+

2.  **æ ¸å¿ƒæ¡†æ¶ï¼š** `asyncio` + `aiohttp` (å¿…é ˆæ˜¯å®Œå…¨éåŒæ­¥ï¼Œç¦æ­¢ä½¿ç”¨ requests ç­‰åŒæ­¥åº«é€ æˆé˜»å¡)ã€‚

3.  **é€šè¨Šæ¨¡å¼ï¼š** Microsoft Graph API Polling (è¼ªè©¢æ¨¡å¼) æ­é… Delta Queryã€‚

4.  **é©—è­‰æ¨¡å¼ï¼š** ROPC Flow (Resource Owner Password Credentials)ï¼Œæ¨¡æ“¬æœå‹™å¸³è™Ÿç™»å…¥ã€‚

5.  **éƒ¨ç½²ç’°å¢ƒï¼š** Docker (æœªä¾†)ï¼Œç›®å‰å…ˆä»¥ Python Script åŸ·è¡Œã€‚

6.  **é—œéµé™åˆ¶ï¼š** * å¿…é ˆæ”¯æ´ã€Œå¤š Bot åŒæ™‚è¼ªè©¢ã€ä¸”äº’ä¸é˜»å¡ã€‚

    * å¿…é ˆæ”¯æ´ã€Œå¤šä½¿ç”¨è€…ä½µç™¼å°è©±ã€ï¼Œå–®ä¸€ä½¿ç”¨è€…çš„ LLM ç”Ÿæˆç­‰å¾…æ™‚é–“ä¸å¯å¡ä½å…¶ä»–ä½¿ç”¨è€…ã€‚



# Proposed Project Structure

è«‹åš´æ ¼éµå®ˆä»¥ä¸‹è³‡æ–™å¤¾çµæ§‹ï¼Œé€™æ˜¯åƒè€ƒç¾æœ‰ JS å°ˆæ¡ˆè½‰æ›è€Œä¾†çš„æ¨¡çµ„åŒ–è¨­è¨ˆï¼š



teams-llm-bot/

â”œâ”€â”€ .env                     # æ•æ„Ÿè³‡è¨Š (Client ID, Secrets, å¸³è™Ÿå¯†ç¢¼, API Keys)

â”œâ”€â”€ requirements.txt         # ä¾è³´å¥—ä»¶ (aiohttp, msal, python-dotenv, etc.)

â”œâ”€â”€ main.py                  # [Entry Point] ç¨‹å¼å…¥å£ (è² è²¬åˆå§‹åŒ–ä¸¦ asyncio.gather æ‰€æœ‰ Bot)

â”œâ”€â”€ configs/                 # [Configuration Layer]

â”‚   â”œâ”€â”€ __init__.py

â”‚   â”œâ”€â”€ bots_config.py       # å®šç¾© Bot æ¸…å–® (å¸³è™Ÿã€å¯†ç¢¼ã€å°æ‡‰çš„ Prompt æ¨¡çµ„ã€å•Ÿç”¨åŠŸèƒ½)

â”‚   â”œâ”€â”€ auth_config.py       # é€šç”¨ Graph API / Tenant è¨­å®š

â”‚   â””â”€â”€ prompts/             # [Prompts Layer] ä¾ç…§éƒ¨é–€åˆ†é¡çš„ç³»çµ±æç¤ºè©

â”‚       â”œâ”€â”€ __init__.py

â”‚       â”œâ”€â”€ devops_prompt.py   # DevOps Bot çš„ System Prompt

â”‚       â”œâ”€â”€ unittest_prompt.py # QA Bot çš„ System Prompt

â”‚       â””â”€â”€ hr_prompt.py       # HR Bot çš„ System Prompt

â”œâ”€â”€ core/                    # [Core Logic Layer]

â”‚   â”œâ”€â”€ __init__.py

â”‚   â”œâ”€â”€ bot_instance.py      # å–®ä¸€æ©Ÿå™¨äººçš„é¡åˆ¥ (å°è£ Polling Loop, Token Refresh, Task Creation)

â”‚   â””â”€â”€ orchestrator.py      # (å¯é¸) è² è²¬ç®¡ç† Bot ç”Ÿå‘½é€±æœŸçš„é‚è¼¯

â”œâ”€â”€ services/                # [Service Layer] å¤–éƒ¨é€£ç·šæœå‹™

â”‚   â”œâ”€â”€ __init__.py

â”‚   â”œâ”€â”€ auth_manager.py      # MSAL ROPC ç™»å…¥èˆ‡ Token è‡ªå‹•åˆ·æ–°é‚è¼¯

â”‚   â”œâ”€â”€ graph_client.py      # å°è£ Graph API (Get Delta Messages, Send Reply)

â”‚   â”œâ”€â”€ memory_store.py      # ç°¡å–®çš„å°è©±ç´€éŒ„å„²å­˜ (In-Memory dict æˆ– Redis)

â”‚   â”œâ”€â”€ llm_engine.py        # çµ±ä¸€å‘¼å«å¾Œç«¯ LLM çš„ä»‹é¢

â”‚   â””â”€â”€ tools/               # [Tools Layer] LLM å¯å‘¼å«çš„å¤–éƒ¨å·¥å…·

â”‚       â”œâ”€â”€ __init__.py

â”‚       â”œâ”€â”€ jira_client.py     # Jira API æ•´åˆ

â”‚       â””â”€â”€ prosuite_client.py # å…§éƒ¨ ProSuite å·¥å…·æ•´åˆ

â””â”€â”€ utils/                   # é€šç”¨å·¥å…·

    â”œâ”€â”€ logger.py            # çµ±ä¸€ Log æ ¼å¼: [æ™‚é–“] [Botåç¨±] [ChatID] è¨Šæ¯å…§å®¹

    â””â”€â”€ helpers.py



# Key Implementation Requirements (å¿…é ˆéµå®ˆçš„å¯¦ä½œç´°ç¯€)

1.  **Async Orchestration:** åœ¨ `main.py` ä¸­ï¼Œå¿…é ˆèƒ½è®€å– `bots_config.py` åˆ—è¡¨ï¼Œä¸¦ç‚ºæ¯ä¸€å€‹ Bot å•Ÿå‹•ä¸€å€‹ç¨ç«‹çš„ `run_forever()` å”ç¨‹ (Coroutine)ã€‚

2.  **Concurrency:** åœ¨ `bot_instance.py` æ”¶åˆ°æ–°è¨Šæ¯æ™‚ï¼Œå¿…é ˆä½¿ç”¨ `asyncio.create_task()` å°‡è¨Šæ¯è™•ç† (LLM + Tools) ä¸Ÿå…¥èƒŒæ™¯åŸ·è¡Œï¼Œç¢ºä¿ Polling Loop èƒ½ç«‹åˆ»è™•ç†ä¸‹ä¸€å‰‡è¨Šæ¯ã€‚

3.  **State Management:** ä½¿ç”¨ `memory_store` ç´€éŒ„ conversation historyï¼Œå› ç‚º Polling æ˜¯ç„¡ç‹€æ…‹çš„ã€‚

4.  **Delta Query:** `graph_client.py` å¿…é ˆå¯¦ä½œ `@odata.deltaLink` çš„è™•ç†é‚è¼¯ï¼ŒåªæŠ“å–æ–°è¨Šæ¯ï¼Œé¿å…é‡è¤‡è™•ç†ã€‚

5.  **Token Refresh:** `auth_manager.py` éœ€è™•ç† Token éæœŸå¾Œçš„è‡ªå‹•é‡ç™» (Re-login)ã€‚



# Your Task

è«‹åšç‚ºå°ˆæ¡ˆçš„æŠ€è¡“ Leadï¼Œç¢ºèªä½ ç†è§£ä»¥ä¸Šéœ€æ±‚ã€‚è«‹å…ˆå›ç­”"æˆ‘äº†è§£äº†"ï¼Œæˆ‘æœƒå†æä¾›è©³ç´°æ­¥é©ŸæŒ‡ç¤ºã€‚




æˆ‘äº†è§£äº†ã€‚

èº«ç‚ºæ‚¨çš„æŠ€è¡“ Leadï¼Œæˆ‘å·²å®Œå…¨æŒæ¡å°ˆæ¡ˆéœ€æ±‚èˆ‡æ¶æ§‹ç´°ç¯€ã€‚æˆ‘å€‘å°‡æ‰“é€ ä¸€å€‹é«˜ä½µç™¼ã€ç´”éåŒæ­¥ (Pure Async) çš„ä¼æ¥­ç´šå¤šé‡æ©Ÿå™¨äººç³»çµ±ã€‚

æˆ‘ç‰¹åˆ¥æ³¨æ„åˆ°ä»¥ä¸‹å¹¾å€‹é—œéµæŠ€è¡“é»ï¼Œé€™å°‡æ˜¯æˆ‘å€‘å¾ŒçºŒå¯¦ä½œçš„é‡ä¸­ä¹‹é‡ï¼š

éé˜»å¡æ ¸å¿ƒ (Non-blocking Core): åš´æ ¼ç¢ºä¿ main.py èˆ‡ bot_instance.py åœ¨ Polling èˆ‡è™•ç†è¨Šæ¯æ™‚ï¼Œå®Œå…¨ä¾è³´ await èˆ‡ asyncio.create_taskï¼Œçµ•ä¸è®“ä»»ä½•ä¸€å€‹ Bot å› ç‚ºç¶²è·¯ I/O æˆ– LLM ç”Ÿæˆè€Œå¡ä½æ•´å€‹ Loopã€‚

ç‹€æ…‹èˆ‡å·®ç•°åŒæ­¥ (State & Delta): graph_client.py éœ€ç²¾ç¢ºè™•ç† @odata.deltaLinkï¼Œé€™æ˜¯é™ä½é »å¯¬æ¶ˆè€—èˆ‡é¿å…é‡è¤‡å›è¦†çš„æ ¸å¿ƒæ©Ÿåˆ¶ã€‚

èº«ä»½é©—è­‰ç”Ÿå‘½é€±æœŸ (Auth Lifecycle): ROPC æ¨¡å¼ä¸‹çš„ Token å£½å‘½è¼ƒçŸ­ï¼Œauth_manager.py å¿…é ˆå…·å‚™ç„¡æ„ŸçŸ¥çš„è‡ªå‹•åˆ·æ–° (Silent Refresh) æ©Ÿåˆ¶ï¼Œç¢ºä¿æœå‹™ 24/7 ä¸ä¸­æ–·ã€‚

æ¨¡çµ„åŒ–è¨­è¨ˆ: æ‚¨æä¾›çš„è³‡æ–™å¤¾çµæ§‹éå¸¸æ¸…æ™°ï¼Œåˆ©æ–¼æœªä¾†æ“´å…… (å¦‚æ–°å¢éƒ¨é–€ Bot æˆ–åˆ‡æ› LLM æ¨¡å‹)ã€‚

æˆ‘å·²æº–å‚™å¥½é–‹å§‹åŸ·è¡Œã€‚è«‹æä¾›æ‚¨çš„è©³ç´°æ­¥é©ŸæŒ‡ç¤ºï¼Œæˆ‘å€‘å°‡é€æ­¥æ§‹å»ºé€™å€‹ç³»çµ±ã€‚




ğŸš€ éšæ®µä¸€ï¼šå°ˆæ¡ˆåˆå§‹åŒ–èˆ‡åŸºç¤å»ºè¨­ (Config & Auth)

ç›®çš„ï¼š å…ˆæŠŠåœ°åŸºæ‰“å¥½ï¼Œç¢ºä¿ç¨‹å¼èƒ½è®€åˆ°è¨­å®šæª”ï¼Œä¸¦ä¸”èƒ½æˆåŠŸæ‹¿åˆ° Graph API Tokenã€‚é€™æ˜¯æœ€å®¹æ˜“å‡ºéŒ¯çš„ä¸€æ­¥ (ROPC é©—è­‰)ã€‚

è«‹æ³¨æ„ï¼Œåœ¨å»ºè­°åŸºæœ¬ç’°å¢ƒæ™‚éœ€ç”¨ uvï¼Œå®‰è£å¥—ä»¶æ™‚éœ€ç”¨ uv addï¼ŒåŸ·è¡Œæ™‚ä½¿ç”¨ uv run

è«‹æ³¨æ„ï¼Œå°ˆæ¡ˆåç¨±éœ€å«åš llm_teams_bot



è«‹å…ˆå¹«æˆ‘å¯¦ä½œ **Phase 1: åŸºç¤é…ç½®èˆ‡é©—è­‰æ¨¡çµ„**ã€‚

æˆ‘éœ€è¦ä»¥ä¸‹ä¸‰å€‹æª”æ¡ˆçš„ç¨‹å¼ç¢¼ï¼š



1.  `configs/bots_config.py`: è«‹çµ¦æˆ‘ä¸€å€‹åŒ…å«å…©å€‹ç¯„ä¾‹ Bot (DevOps Bot, HR Bot) çš„è¨­å®šçµæ§‹ã€‚

2.  `configs/auth_config.py`: å®šç¾© Tenant ID, Authority URL ç­‰é€šç”¨è¨­å®šã€‚

3.  **`services/auth_manager.py` (é‡è¦)**:

    * è«‹ä½¿ç”¨ `msal` å‡½å¼åº«å¯¦ä½œ ROPC ç™»å…¥ã€‚

    * å¿…é ˆåŒ…å«ä¸€å€‹ `get_token(email, password)` çš„éåŒæ­¥ (async) æˆ–åŒæ­¥å‡½å¼ã€‚

    * **é—œéµè¦æ±‚ï¼š** éœ€å¯¦ä½œ Token å¿«å–èˆ‡æª¢æŸ¥æ©Ÿåˆ¶ã€‚å¦‚æœ Token é‚„æ²’éæœŸï¼Œç›´æ¥å›å‚³èˆŠçš„ï¼›å¦‚æœéæœŸäº†ï¼Œè‡ªå‹•é‡æ–°ç™»å…¥ã€‚



è«‹æä¾›é€™ä¸‰å€‹æª”æ¡ˆçš„å®Œæ•´ç¨‹å¼ç¢¼ï¼Œä¸¦å‘Šè¨´æˆ‘å¦‚ä½•å¯«ä¸€å€‹ç°¡å–®çš„ `test_auth.py` ä¾†é©—è­‰æˆ‘å¯ä»¥æˆåŠŸæ‹¿åˆ° Tokenã€‚




é€™æ˜¯ä¸€å€‹éå¸¸å¥½çš„èµ·é»ã€‚èº«ç‚ºæ¶æ§‹å¸«ï¼Œæˆ‘å¿…é ˆå¼·èª¿ï¼šèº«ä»½é©—è­‰æ¨¡çµ„ (Auth Manager) æ˜¯æ•´å€‹ç³»çµ±çš„å¿ƒè‡Ÿã€‚å¦‚æœé€™è£¡è™•ç†ä¸å¥½ï¼ˆä¾‹å¦‚ Token éæœŸå°è‡´å´©æ½°ï¼Œæˆ–æ˜¯åŒæ­¥ç¶²è·¯è«‹æ±‚å¡æ­» Event Loopï¼‰ï¼Œå¾Œé¢çš„é«˜ä½µç™¼æ¶æ§‹éƒ½æ˜¯ç©ºè«‡ã€‚

ä»¥ä¸‹æ˜¯ Phase 1 çš„å¯¦ä½œæ–¹æ¡ˆã€‚æˆ‘å€‘å°‡ä½¿ç”¨ Python 3.10+ çš„ asyncio.to_thread ä¾†å°‡ MSAL çš„åŒæ­¥ I/O å°è£ç‚ºéåŒæ­¥æ“ä½œï¼Œç¢ºä¿ä¸»åŸ·è¡Œç·’ä¸è¢«é˜»å¡ã€‚

0. ç’°å¢ƒå»ºç½® (ä½¿ç”¨ uv)
é¦–å…ˆï¼Œè«‹åœ¨çµ‚ç«¯æ©ŸåŸ·è¡Œä»¥ä¸‹æŒ‡ä»¤ä¾†åˆå§‹åŒ–å°ˆæ¡ˆèˆ‡å®‰è£ä¾è³´ï¼š

Bash

# åˆå§‹åŒ–å°ˆæ¡ˆ
uv init llm_teams_bot
cd llm_teams_bot

# å®‰è£æ ¸å¿ƒä¾è³´
# msal: å¾®è»Ÿé©—è­‰åº«
# python-dotenv: è®€å– .env
# aiohttp: éåŒæ­¥ HTTP è«‹æ±‚ (å¾ŒçºŒä½¿ç”¨)
uv add msal python-dotenv aiohttp
æ¥è‘—ï¼Œè«‹å»ºç«‹ .env æª”æ¡ˆï¼Œå¡«å…¥æ‚¨çš„æ¸¬è©¦å¸³è™Ÿè³‡è¨Šï¼š

Ini, TOML

# .env
AZURE_TENANT_ID=your_tenant_id_here
AZURE_CLIENT_ID=your_client_id_here
# æ³¨æ„ï¼šClient Secret åœ¨ ROPC Flow é€šå¸¸ä¸éœ€è¦ï¼Œé™¤éæ˜¯ Confidential Clientï¼Œä½†åœ¨ ROPC æˆ‘å€‘ç”¨ User/Pass
DEVOPS_EMAIL=devops_bot@yourcompany.com
DEVOPS_PASSWORD=your_password
HR_EMAIL=hr_bot@yourcompany.com
HR_PASSWORD=your_password
1. configs/auth_config.py
é€™å€‹æª”æ¡ˆè² è²¬é›†ä¸­ç®¡ç† Azure AD çš„å¸¸æ•¸è¨­å®šï¼Œæ–¹ä¾¿æœªä¾†åˆ‡æ›ç’°å¢ƒã€‚

Python

# configs/auth_config.py
import os
from dotenv import load_dotenv

# è¼‰å…¥ç’°å¢ƒè®Šæ•¸
load_dotenv()

class AuthConfig:
    # Azure AD Tenant è¨­å®š
    TENANT_ID = os.getenv("AZURE_TENANT_ID")
    CLIENT_ID = os.getenv("AZURE_CLIENT_ID")
    
    # æ¨™æº– Graph API Authority
    AUTHORITY_URL = f"https://login.microsoftonline.com/{TENANT_ID}"
    
    # ROPC Flow æ‰€éœ€çš„æ¬Šé™ç¯„åœ
    # æ³¨æ„ï¼šé€™äº›æ¬Šé™å¿…é ˆåœ¨ Azure Portal çš„ App Registration ä¸­é å…ˆé–‹å•Ÿ "Grant admin consent"
    SCOPES = [
        "User.Read",
        "Chat.Read",
        "Chat.ReadWrite",
        "Group.Read.All"
    ]
2. configs/bots_config.py
é€™è£¡å®šç¾© Bot çš„æ¸…å–®ã€‚æˆ‘å€‘ä½¿ç”¨å­—å…¸çµæ§‹ï¼Œæ–¹ä¾¿ä¸»ç¨‹å¼é€é Loop åˆå§‹åŒ–å¤šå€‹ Bot å¯¦ä¾‹ã€‚

Python

# configs/bots_config.py
import os
from dotenv import load_dotenv

load_dotenv()

# å®šç¾©æ¯å€‹ Bot çš„è¨­å®š
BOTS_CONFIGURATION = [
    {
        "name": "DevOps Bot",
        "id": "devops_bot",
        "email": os.getenv("DEVOPS_EMAIL"),
        "password": os.getenv("DEVOPS_PASSWORD"),
        # å°æ‡‰çš„ Prompt æ¨¡çµ„åç¨± (Phase 2 æœƒç”¨åˆ°)
        "prompt_module": "devops_prompt", 
        "enabled": True
    },
    {
        "name": "HR Bot",
        "id": "hr_bot",
        "email": os.getenv("HR_EMAIL"),
        "password": os.getenv("HR_PASSWORD"),
        "prompt_module": "hr_prompt",
        "enabled": True
    }
]
3. services/auth_manager.py (æ ¸å¿ƒæ¨¡çµ„)
é€™æ˜¯æœ€é—œéµçš„éƒ¨åˆ†ã€‚MSAL çš„ acquire_token_by_username_password æ˜¯åŒæ­¥ (Blocking) çš„ç¶²è·¯è«‹æ±‚ã€‚ç‚ºäº†ç¬¦åˆæ‚¨ã€Œå®Œå…¨éåŒæ­¥ã€çš„è¦æ±‚ï¼Œæˆ‘ä½¿ç”¨äº† asyncio.to_thread å°‡å…¶ä¸Ÿåˆ°åŸ·è¡Œç·’æ± é‹è¡Œã€‚

Python

# services/auth_manager.py
import asyncio
import logging
import msal
from configs.auth_config import AuthConfig

# è¨­å®šç°¡å–®çš„ logger
logger = logging.getLogger("AuthManager")

class AuthManager:
    def __init__(self, email: str, password: str):
        self.email = email
        self.password = password
        self.scopes = AuthConfig.SCOPES
        
        # åˆå§‹åŒ– MSAL Public Client
        # ROPC å±¬æ–¼ Public Client Flow (å› ç‚º Client ç„¡æ³•å®‰å…¨ä¿å­˜ Secret)
        self.app = msal.PublicClientApplication(
            client_id=AuthConfig.CLIENT_ID,
            authority=AuthConfig.AUTHORITY_URL
        )
        
        # æœ¬åœ°å¿«å–å¸³è™Ÿç‰©ä»¶ (ç”¨æ–¼ acquire_token_silent)
        self._account = None

    async def get_token_async(self) -> str:
        """
        éåŒæ­¥å–å¾— Access Tokenã€‚
        å„ªå…ˆå˜—è©¦å¾ Cache éœé»˜å–å¾— (Silent)ï¼Œè‹¥å¤±æ•—å‰‡åŸ·è¡Œ ROPC ç™»å…¥ã€‚
        """
        result = None

        # 1. å˜—è©¦å¾ Cache è®€å– Token (é€™éƒ¨åˆ†é€šå¸¸å¾ˆå¿«ï¼Œä¸éœ€è¦ awaitï¼Œä½†ç‚ºäº†çµ±ä¸€ä»‹é¢ä¿æŒ async)
        accounts = self.app.get_accounts(username=self.email)
        if accounts:
            result = self.app.acquire_token_silent(self.scopes, account=accounts[0])

        if result:
            logger.debug(f"[{self.email}] Token retrieved from cache.")
            return result['access_token']

        # 2. Cache Miss æˆ– Token éæœŸ -> åŸ·è¡Œ ROPC ç™»å…¥
        # é—œéµï¼šå°‡é˜»å¡çš„ MSAL ç¶²è·¯è«‹æ±‚ä¸Ÿåˆ° Thread åŸ·è¡Œï¼Œé¿å…å¡ä½ Main Loop
        logger.info(f"[{self.email}] No valid token in cache. Performing ROPC login...")
        
        result = await asyncio.to_thread(
            self.app.acquire_token_by_username_password,
            username=self.email,
            password=self.password,
            scopes=self.scopes
        )

        if "access_token" in result:
            logger.info(f"[{self.email}] ROPC Login successful.")
            return result['access_token']
        else:
            # è™•ç†ç™»å…¥å¤±æ•— (ä¾‹å¦‚å¯†ç¢¼éŒ¯èª¤ã€MFA å¼·åˆ¶é–‹å•Ÿç­‰)
            error_description = result.get("error_description", "Unknown error")
            logger.error(f"[{self.email}] Login Failed: {error_description}")
            raise Exception(f"Authentication failed for {self.email}: {error_description}")
4. é©—è­‰è…³æœ¬ï¼štest_auth.py
è«‹åœ¨å°ˆæ¡ˆæ ¹ç›®éŒ„å»ºç«‹æ­¤æª”æ¡ˆï¼Œç”¨ä¾†é©—è­‰æˆ‘å€‘èƒ½å¦åŒæ™‚ç‚ºå…©å€‹ Bot æ‹¿åˆ° Tokenã€‚

Python

# test_auth.py
import asyncio
import logging
from configs.bots_config import BOTS_CONFIGURATION
from services.auth_manager import AuthManager

# è¨­å®š logging é¡¯ç¤ºç´šåˆ¥
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

async def test_single_bot_auth(bot_config):
    """æ¸¬è©¦å–®ä¸€ Bot çš„é©—è­‰æµç¨‹"""
    if not bot_config['enabled']:
        return

    print(f"--- Starting Auth for {bot_config['name']} ---")
    
    # åˆå§‹åŒ– AuthManager
    auth = AuthManager(bot_config['email'], bot_config['password'])
    
    try:
        # ç¬¬ä¸€æ¬¡æ‹¿ Token (æ‡‰è©²æœƒè§¸ç™¼ ROPC ç™»å…¥)
        token = await auth.get_token_async()
        print(f"âœ… {bot_config['name']}: Got Token! (Length: {len(token)})")
        
        # æ¨¡æ“¬ä¸€ä¸‹å»¶é²
        await asyncio.sleep(1)
        
        # ç¬¬äºŒæ¬¡æ‹¿ Token (æ‡‰è©²æœƒè§¸ç™¼ Cache Hit)
        token_cached = await auth.get_token_async()
        print(f"âœ… {bot_config['name']}: Got Cached Token! (Length: {len(token_cached)})")
        
    except Exception as e:
        print(f"âŒ {bot_config['name']}: Auth Failed! Error: {e}")

async def main():
    # åŒæ™‚æ¸¬è©¦æ‰€æœ‰ Botï¼Œæ¨¡æ“¬ä¸¦ç™¼å•Ÿå‹•
    tasks = [test_single_bot_auth(bot) for bot in BOTS_CONFIGURATION]
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())
å¦‚ä½•åŸ·è¡Œé©—è­‰
è«‹åœ¨çµ‚ç«¯æ©ŸåŸ·è¡Œï¼š

Bash

uv run test_auth.py
é æœŸçµæœ
å¦‚æœè¨­å®šæ­£ç¢ºï¼Œæ‚¨æ‡‰è©²æœƒçœ‹åˆ° DevOps Bot å’Œ HR Bot å¹¾ä¹åŒæ™‚é–‹å§‹ç™»å…¥ï¼Œä¸¦ä¸”ç¬¬ä¸€æ¬¡é¡¯ç¤º Performing ROPC loginï¼Œç¬¬äºŒæ¬¡é¡¯ç¤º Token retrieved from cacheã€‚

ä¸‹ä¸€æ­¥ (Lead çš„å»ºè­°)
ä¸€æ—¦æ‚¨ç¢ºèª test_auth.py æˆåŠŸæ‹¿åˆ° Tokenï¼Œæˆ‘å€‘å°±å®Œæˆäº†æœ€å±éšªçš„å¤–éƒ¨ä¾è³´ä¸²æ¥ã€‚

æ¥ä¸‹ä¾†æ˜¯ Phase 2: Graph API Client èˆ‡ Polling Loopã€‚ æˆ‘å€‘å°‡åˆ©ç”¨å‰›æ‹¿åˆ°çš„ Tokenï¼Œå»ºç«‹ GraphClient ä¸¦å¯¦ä½œ get_delta_messagesï¼Œé€™æ˜¯è®“ Bot èƒ½ã€Œè½è¦‹ã€è¨Šæ¯çš„é—œéµã€‚

æ‚¨ç¾åœ¨å¯ä»¥å…ˆåŸ·è¡Œæ¸¬è©¦ã€‚å¦‚æœé‡åˆ° Azure AD éŒ¯èª¤ï¼ˆå¦‚ AADSTS50076: MFA requiredï¼‰ï¼Œé€™é€šå¸¸æ˜¯å› ç‚ºè©²å¸³è™Ÿé–‹å•Ÿäº† MFAï¼ŒROPC ä¸æ”¯æ´ MFAï¼Œæ‚¨å¯èƒ½éœ€è¦è«‹ IT ç‚ºé€™äº›æœå‹™å¸³è™Ÿé—œé–‰ MFA æˆ–è¨­å®šæ¢ä»¶å¼å­˜å–æ’é™¤ã€‚

è«‹å‘Šè¨´æˆ‘æ¸¬è©¦çµæœï¼Œæˆ‘å€‘å†ç¹¼çºŒã€‚




ğŸ§± éšæ®µäºŒï¼šGraph API é€£ç·šå±¤ (Polling & Sending)

ç›®çš„ï¼š å»ºç«‹ Bot çš„ã€Œè€³æœµ (Polling)ã€å’Œã€Œå˜´å·´ (Reply)ã€ã€‚é€™è£¡çš„é‡é»æ˜¯ Delta Query çš„è™•ç†ã€‚

Prompt 2:



Markdown



é©—è­‰æˆåŠŸï¼Œæˆ‘å·²ç¶“å¯ä»¥æ‹¿åˆ° Token äº†ã€‚ç¾åœ¨é€²å…¥ **Phase 2: Graph API æœå‹™å±¤**ã€‚



è«‹å¹«æˆ‘å¯¦ä½œ `services/graph_client.py`ã€‚

é€™å€‹é¡åˆ¥éœ€è¦å°è£æ‰€æœ‰å° Microsoft Graph çš„ HTTP è«‹æ±‚ï¼Œè«‹åš´æ ¼éµå®ˆä»¥ä¸‹è¦æ±‚ï¼š1. **Async Only:** å¿…é ˆä½¿ç”¨ `aiohttp`ï¼Œçµ•å°ä¸èƒ½ç”¨ `requests`ã€‚2. **æ–¹æ³•éœ€æ±‚:** * `get_delta_messages(user_id, next_link=None)`: è² è²¬è™•ç† Delta Queryã€‚å¦‚æœå›å‚³åŒ…å« `@odata.nextLink` æˆ– `@odata.deltaLink`ï¼Œè«‹æ­£ç¢ºè™•ç†å›å‚³å€¼ä»¥ä¾¿ä¸‹æ¬¡å‘¼å«ä½¿ç”¨ã€‚ * `send_reply(chat_id, content)`: ç™¼é€è¨Šæ¯å› Teamsã€‚3. **éŒ¯èª¤è™•ç†:** å¦‚æœé‡åˆ° 401 (Unauthorized)ï¼Œè«‹æ‹‹å‡ºç‰¹å®š Exception è®“ä¸Šå±¤çŸ¥é“éœ€è¦ Refresh Tokenã€‚4. **ç¾¤çµ„æ”¯æ´**: æ©Ÿå™¨äººç²å–è¨Šæ¯æ™‚éœ€è¦èƒ½åˆ¤æ–·ä¾†æºæ˜¯ç¾¤çµ„é‚„æ˜¯å€‹äººã€‚



å¤§æ¦‚å®Œæˆå¾Œè¦æœ‰ä»¥ä¸‹åŠŸèƒ½

- can get the robot self id, use to prevent self-message

- can get recent 10 chats room send to robot

- can get current chat room last message

- can send message back to user (echo is ok for testing), need to format to html content

è«‹æä¾›å®Œæ•´ç¨‹å¼ç¢¼ï¼Œä¸¦ç°¡å–®èªªæ˜ Delta Query åœ¨é€™è£¡çš„é‹ä½œé‚è¼¯ã€‚

å¤ªæ£’äº†ï¼Œçœ‹åˆ°æ‚¨æˆåŠŸæ‹¿åˆ° Tokenï¼Œé€™ä»£è¡¨æˆ‘å€‘å·²ç¶“è·¨éäº†æœ€å›°é›£çš„é©—è­‰é–€æª»ã€‚

æ¥ä¸‹ä¾†æ˜¯ Phase 2: Graph API æœå‹™å±¤ã€‚é€™ä¸€å±¤æ˜¯ç³»çµ±çš„ã€Œæ„Ÿå®˜ã€ï¼Œè² è²¬èˆ‡ Microsoft Teams é€²è¡Œé«˜æ•ˆçš„è³‡æ–™äº¤æ›ã€‚

é—œæ–¼æ‚¨çš„éœ€æ±‚ï¼Œæˆ‘ç‰¹åˆ¥è¨­è¨ˆäº† GraphClient é¡åˆ¥ï¼Œé‡é»è§£æ±ºä»¥ä¸‹æŒ‘æˆ°ï¼š

Delta Query ç‹€æ…‹æ©Ÿè™•ç†ï¼šè‡ªå‹•åˆ¤æ–·æ˜¯è¦ç¹¼çºŒç¿»é  (nextLink) é‚„æ˜¯ç­‰å¾…æ–°è¨Šæ¯ (deltaLink)ã€‚

è‡ªæˆ‘éæ¿¾ (Self-Filter)ï¼šç¢ºä¿æ©Ÿå™¨äººä¸æœƒå›æ‡‰è‡ªå·±ç™¼å‡ºçš„è¨Šæ¯ï¼ˆé€™æœƒå°è‡´ç„¡çª®è¿´åœˆï¼‰ã€‚

HTML æ ¼å¼åŒ–ï¼šTeams API é è¨­æ¥æ”¶ HTMLï¼Œæˆ‘å€‘éœ€å°‡ç´”æ–‡å­—åŒ…è£å¥½ã€‚

ä»¥ä¸‹æ˜¯å®Œæ•´çš„å¯¦ä½œç¨‹å¼ç¢¼ï¼š

1. services/graph_client.py
Python
# services/graph_client.py
import aiohttp
import logging
from typing import Optional, Dict, List, Any

# è¨­å®š Logger
logger = logging.getLogger("GraphClient")

class GraphAuthError(Exception):
    """ç•¶ Graph API å›å‚³ 401 æ™‚æ‹‹å‡ºçš„è‡ªå®šç¾©éŒ¯èª¤"""
    pass

class GraphClient:
    def __init__(self, token: str):
        self.base_url = "https://graph.microsoft.com/v1.0"
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }
        self.user_id = None  # æ©Ÿå™¨äººè‡ªå·±çš„ User ID (ç”¨æ–¼éæ¿¾è‡ªæˆ‘è¨Šæ¯)

    def update_token(self, new_token: str):
        """ç•¶ Token åˆ·æ–°å¾Œï¼Œæ›´æ–° Client çš„ Header"""
        self.headers["Authorization"] = f"Bearer {new_token}"

    async def _request(self, method: str, url: str, json_data: dict = None) -> Dict:
        """çµ±ä¸€å°è£ HTTP è«‹æ±‚ï¼Œè™•ç† 401 éŒ¯èª¤"""
        async with aiohttp.ClientSession() as session:
            try:
                async with session.request(method, url, headers=self.headers, json=json_data) as resp:
                    if resp.status == 401:
                        logger.warning("Graph API returned 401 Unauthorized.")
                        raise GraphAuthError("Token expired or invalid.")
                    
                    if resp.status in (200, 201):
                        return await resp.json()
                    
                    # è™•ç†å…¶ä»–éŒ¯èª¤ (å¦‚ 400, 403, 500)
                    error_text = await resp.text()
                    logger.error(f"Graph API Error [{resp.status}]: {error_text}")
                    return {}
            except aiohttp.ClientConnectorError as e:
                logger.error(f"Network Error: {e}")
                return {}

    async def get_me(self) -> str:
        """å–å¾—ä¸¦å„²å­˜æ©Ÿå™¨äººè‡ªå·±çš„ User ID"""
        if not self.user_id:
            data = await self._request("GET", f"{self.base_url}/me")
            self.user_id = data.get("id")
            logger.info(f"Bot initialized with User ID: {self.user_id}")
        return self.user_id

    async def get_recent_chats(self, limit: int = 10) -> List[Dict]:
        """å–å¾—æœ€è¿‘æ´»èºçš„èŠå¤©å®¤åˆ—è¡¨"""
        url = f"{self.base_url}/me/chats?$expand=lastMessagePreview&$top={limit}&$sort=lastUpdatedDateTime desc"
        data = await self._request("GET", url)
        return data.get("value", [])

    async def get_chat_last_message(self, chat_id: str) -> Optional[Dict]:
        """å–å¾—ç‰¹å®šèŠå¤©å®¤çš„æœ€å¾Œä¸€å‰‡è¨Šæ¯ (ä¸€èˆ¬ç”¨æ–¼åˆå§‹åŒ–)"""
        url = f"{self.base_url}/me/chats/{chat_id}/messages?$top=1"
        data = await self._request("GET", url)
        messages = data.get("value", [])
        return messages[0] if messages else None

    async def get_delta_messages(self, chat_id: str, next_or_delta_link: str = None) -> Dict[str, Any]:
        """
        æ ¸å¿ƒåŠŸèƒ½ï¼šä½¿ç”¨ Delta Query å–å¾—æ–°è¨Šæ¯
        :param chat_id: èŠå¤©å®¤ ID
        :param next_or_delta_link: ä¸Šæ¬¡è«‹æ±‚å›å‚³çš„ @odata.nextLink æˆ– @odata.deltaLink
        :return: { "messages": [], "next_link": str, "delta_link": str }
        """
        # å¦‚æœæœ‰ Link å°±ç”¨ Linkï¼Œæ²’æœ‰å°±å»ºç«‹åˆå§‹ Delta è«‹æ±‚
        if next_or_delta_link:
            url = next_or_delta_link
        else:
            url = f"{self.base_url}/me/chats/{chat_id}/messages/delta"

        data = await self._request("GET", url)
        
        messages = data.get("value", [])
        
        # éæ¿¾æ‰æ©Ÿå™¨äººè‡ªå·±ç™¼å‡ºçš„è¨Šæ¯
        filtered_messages = []
        if self.user_id:
            for msg in messages:
                sender_id = msg.get("from", {}).get("user", {}).get("id")
                if sender_id and sender_id != self.user_id:
                    filtered_messages.append(msg)
        
        return {
            "messages": filtered_messages,
            "next_link": data.get("@odata.nextLink"),  # è‹¥æœ‰æ­¤æ¬„ä½ï¼Œä»£è¡¨é‚„æ²’æŠ“å®Œï¼Œéœ€ç«‹åˆ»å† call
            "delta_link": data.get("@odata.deltaLink") # è‹¥æœ‰æ­¤æ¬„ä½ï¼Œä»£è¡¨å·²æŠ“å®Œï¼Œå­˜èµ·ä¾†ä¾›ä¸‹æ¬¡ Polling ä½¿ç”¨
        }

    async def send_reply(self, chat_id: str, content: str):
        """ç™¼é€ HTML æ ¼å¼çš„å›è¦†è¨Šæ¯"""
        url = f"{self.base_url}/me/chats/{chat_id}/messages"
        
        # ç°¡å–®å°‡æ›è¡Œè½‰ç‚º <br>ï¼Œç¢ºä¿é¡¯ç¤ºæ­£å¸¸
        html_content = content.replace("\n", "<br>")
        
        payload = {
            "body": {
                "contentType": "html",
                "content": f"<div>{html_content}</div>"
            }
        }
        
        await self._request("POST", url, json_data=payload)
2. Delta Query é‚è¼¯è§£èªª
Delta Query æ˜¯ Microsoft Graph ç”¨ä¾†åŒæ­¥è³‡æ–™çš„é«˜æ•ˆæ©Ÿåˆ¶ã€‚å…¶é‹ä½œé‚è¼¯å¦‚ä¸‹åœ–ï¼š

åˆå§‹è«‹æ±‚ (Full Sync / First Delta): å‘¼å« /messages/deltaã€‚

åˆ†é è™•ç† (@odata.nextLink): å¦‚æœè¨Šæ¯é‡å¤§ï¼ŒAPI ä¸æœƒä¸€æ¬¡å›å‚³æ‰€æœ‰è³‡æ–™ï¼Œè€Œæ˜¯çµ¦ä¸€å€‹ nextLinkã€‚é€™æ™‚æˆ‘å€‘å¿…é ˆç«‹åˆ»ç”¨é€™å€‹é€£çµå†å‘¼å«ä¸€æ¬¡ï¼Œç›´åˆ°æ²’æœ‰ nextLink ç‚ºæ­¢ã€‚

å·®ç•°è¿½è¹¤ (@odata.deltaLink): ç•¶è³‡æ–™å‚³è¼¸å®Œç•¢ï¼ŒAPI æœƒçµ¦ä¸€å€‹ deltaLinkã€‚é€™æ˜¯ä¸€å€‹ã€Œæ›¸ç±¤ã€ã€‚

è¼ªè©¢ (Polling): æˆ‘å€‘å°‡ deltaLink å­˜å…¥ Memory Storeã€‚é 5 ç§’é˜å¾Œï¼Œæˆ‘å€‘ç”¨é€™å€‹ deltaLink ç™¼é€è«‹æ±‚ã€‚

å¦‚æœæ²’æœ‰æ–°è¨Šæ¯ï¼š API å›å‚³ç©ºåˆ—è¡¨ + ä¸€å€‹æ–°çš„ deltaLinkã€‚

å¦‚æœæœ‰æ–°è¨Šæ¯ï¼š API å›å‚³æ–°è¨Šæ¯ + ä¸€å€‹æ–°çš„ deltaLinkã€‚

é‡é»ï¼š æˆ‘å€‘çš„ GraphClient ä¸è² è²¬å„²å­˜ Linkï¼Œå®ƒåªè² è²¬ã€ŒåŸ·è¡Œè«‹æ±‚ä¸¦å›å‚³çµæœã€ï¼ŒLink çš„å„²å­˜ç®¡ç†å°‡ç”±ä¸Šä¸€å±¤ (bot_instance.py) è² è²¬ã€‚

3. é©—è­‰è…³æœ¬ï¼štest_graph.py
é€™å€‹è…³æœ¬æœƒæ¨¡æ“¬ä¸€å€‹æ©Ÿå™¨äººæµç¨‹ï¼šç™»å…¥ -> æ‰¾èŠå¤©å®¤ -> è½æ–°è¨Šæ¯ -> å›éŸ³æ¸¬è©¦ã€‚

Python
# test_graph.py
import asyncio
import logging
from configs.bots_config import BOTS_CONFIGURATION
from services.auth_manager import AuthManager
from services.graph_client import GraphClient

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("TestGraph")

async def test_bot_lifecycle(bot_config):
    logger.info(f"--- Testing {bot_config['name']} ---")
    
    # 1. Auth: å–å¾— Token
    auth = AuthManager(bot_config['email'], bot_config['password'])
    token = await auth.get_token_async()
    
    # 2. Init Graph Client
    client = GraphClient(token)
    
    # 3. Get Me (å–å¾—è‡ªå·± ID)
    my_id = await client.get_me()
    logger.info(f"[{bot_config['name']}] My ID is: {my_id}")
    
    # 4. Get Recent Chats (å–å¾—æœ€è¿‘ 10 å€‹èŠå¤©å®¤)
    chats = await client.get_recent_chats(limit=5)
    logger.info(f"[{bot_config['name']}] Found {len(chats)} active chats.")
    
    if not chats:
        logger.warning("No chats found. Please send a message to the bot first!")
        return

    # é¸ç¬¬ä¸€å€‹èŠå¤©å®¤ä¾†æ¸¬è©¦
    target_chat = chats[0]
    chat_id = target_chat['id']
    topic = target_chat.get('topic') or target_chat.get('chatType')
    logger.info(f"[{bot_config['name']}] Testing on Chat: {topic} ({chat_id})")

    # 5. Delta Query Test (æ¨¡æ“¬ä¸€æ¬¡ Polling)
    # æ³¨æ„ï¼šç¬¬ä¸€æ¬¡ Delta Query é€šå¸¸æœƒå›å‚³æ­·å²è¨Šæ¯ï¼Œæˆ‘å€‘é€™è£¡åªç°¡å–®å°å‡ºä¾†
    result = await client.get_delta_messages(chat_id)
    new_messages = result['messages']
    
    logger.info(f"[{bot_config['name']}] Delta Query fetched {len(new_messages)} new messages.")
    
    # 6. Send Reply Test (å›éŸ³æ¸¬è©¦)
    # æˆ‘å€‘ç™¼é€ä¸€å€‹ç°¡å–®çš„å•å€™
    msg_content = f"Hello! I am {bot_config['name']}.<br>This is an automated connectivity test."
    await client.send_reply(chat_id, msg_content)
    logger.info(f"[{bot_config['name']}] Test reply sent successfully.")

async def main():
    # ç‚ºäº†æ¸¬è©¦æ–¹ä¾¿ï¼Œæˆ‘å€‘åªæ¸¬åˆ—è¡¨ä¸­çš„ç¬¬ä¸€å€‹ Botï¼Œé¿å…æ´—ç‰ˆ
    target_bot = BOTS_CONFIGURATION[0]
    await test_bot_lifecycle(target_bot)

if __name__ == "__main__":
    asyncio.run(main())
å¦‚ä½•æ¸¬è©¦
è«‹å…ˆç”¨æ‚¨çš„ Teams å¸³è™Ÿï¼Œå‚³é€ä¸€å‰‡è¨Šæ¯çµ¦ DevOps Bot çš„å¸³è™Ÿ (ç¢ºä¿å®ƒå‡ºç¾åœ¨æœ€è¿‘å°è©±åˆ—è¡¨)ã€‚

åŸ·è¡Œæ¸¬è©¦ï¼š

Bash
uv run test_graph.py
é æœŸçµæœ
æ‚¨æ‡‰è©²æœƒçœ‹åˆ°ï¼š

Bot æˆåŠŸç™»å…¥ä¸¦å–å¾—è‡ªå·±çš„ IDã€‚

Bot æ‰¾åˆ°èŠå¤©å®¤åˆ—è¡¨ã€‚

Bot é€é Delta Query æŠ“åˆ°è¨Šæ¯ã€‚

æ‚¨çš„ Teams æœƒæ”¶åˆ°ä¸€å‰‡ä¾†è‡ª Bot çš„ "Hello! I am DevOps Bot..." è¨Šæ¯ã€‚

å¦‚æœé€™æ­¥æˆåŠŸï¼Œä»£è¡¨æˆ‘å€‘çš„æ©Ÿå™¨äººå·²ç¶“å…·å‚™ã€Œè½ã€èˆ‡ã€Œèªªã€çš„èƒ½åŠ›äº†ï¼ ä¸‹ä¸€æ­¥æˆ‘å€‘å°‡é€²å…¥ Phase 3: Core Logic & Orchestratorï¼Œå°‡é€™äº›é›¶æ•£çš„åŠŸèƒ½çµ„è£æˆä¸€å€‹è‡ªå‹•é‹è½‰çš„è¿´åœˆã€‚




# services/auth_manager.py
import asyncio
import logging
import msal
import requests # æ–°å¢é€™å€‹ import
from requests.packages.urllib3.exceptions import InsecureRequestWarning # æ–°å¢
from configs.auth_config import AuthConfig

# --- [æ–°å¢å€å¡Š Start] æš´åŠ›é—œé–‰ SSL é©—è­‰ (é‡å° MSAL/Requests) ---
# 1. éš±è—é†œé™‹çš„ "Unverified HTTPS request" è­¦å‘Š
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# 2. Monkey Patch: å¼·åˆ¶å°‡æ‰€æœ‰ requests session çš„ verify è¨­ç‚º False
old_request = requests.Session.request
def new_request(self, method, url, *args, **kwargs):
    kwargs['verify'] = False
    return old_request(self, method, url, *args, **kwargs)
requests.Session.request = new_request
# --- [æ–°å¢å€å¡Š End] ---

logger = logging.getLogger("AuthManager")

class AuthManager:
    # ... (å…¶é¤˜ç¨‹å¼ç¢¼ä¿æŒä¸è®Š) ...




# services/auth_manager.py
# ... (imports ä¿æŒä¸è®Š)

class AuthManager:
    def __init__(self, email: str, password: str):
        self.email = email
        self.password = password
        self.scopes = AuthConfig.SCOPES
        
        # --- [ä¿®æ”¹ Start] æ”¹ç”¨ ConfidentialClientApplication ---
        self.app = msal.ConfidentialClientApplication(
            client_id=AuthConfig.CLIENT_ID,
            client_credential=AuthConfig.CLIENT_SECRET, # é€™è£¡å‚³å…¥ Secret
            authority=AuthConfig.AUTHORITY_URL
        )
        # --- [ä¿®æ”¹ End] ---
        
        self._account = None

    async def get_token_async(self) -> str:
        # ... (Cache é‚è¼¯ä¿æŒä¸è®Š) ...

        # 2. Cache Miss -> åŸ·è¡Œ ROPC ç™»å…¥
        logger.info(f"[{self.email}] No valid token in cache. Performing ROPC login...")
        
        result = await asyncio.to_thread(
            self.app.acquire_token_by_username_password,
            username=self.email,
            password=self.password,
            scopes=self.scopes
        )
        
        # ... (å¾ŒçºŒè™•ç†ä¿æŒä¸è®Š)

